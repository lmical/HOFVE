MODULE exact_riemann_mod
  !
  ! Auteur : T. Toro et M. Dumbser
  !
  !
  !----------------------------------------------------------------------------
  IMPLICIT NONE
  PRIVATE
  !----------------------------------------------------------------------------


  INTERFACE exact_riemann
     MODULE PROCEDURE exact_riemann
  END INTERFACE exact_riemann

  INTERFACE sample
     MODULE PROCEDURE sample
  END INTERFACE sample



  !----------------------------------------------------------------------------
  PUBLIC  :: exact_riemann
  PUBLIC  :: sample
  PUBLIC  :: G
  !----------------------------------------------------------------------------

  REAL        :: tol=1.E-3
  INTEGER     :: nIter = 1000
  REAL        :: G(9)
CONTAINS




  SUBROUTINE coeff(gamma, G)
    !*-------------------------------------------------------
    IMPLICIT NONE
    !*-------------------------------------------------------
    REAL, INTENT(in):: gamma
    REAL, DIMENSION(9), INTENT(out):: G
    G     = (/ (gamma-1.0)/(2.0*gamma), &              ! Groessen, die nur von 
         (gamma+1.0)/(2.0*gamma), &              ! gamma abhaengen, aber
         2.0*gamma/(gamma-1.0),   &              ! oft vom Riemannloeser
         2.0/(gamma-1.0),         &              ! verwendet werden. 
         2.0/(gamma+1.0),         &              ! Um CPU Zeit zu sparen
         (gamma-1.0)/(gamma+1.0), &              ! werden sie nur einmal
         0.5*(gamma-1.0),         &              ! ausgerechnet.
         1.0/gamma,               &              !
         gamma-1.0               /)
  END SUBROUTINE coeff

  SUBROUTINE exact_riemann(gamma,rhol,rhor,rho_star_l,rho_star_r,ul,ur,u,&
       & pl,pr,p,al,ar,speedl, speedr,flag)
    !-------------------------------------------------------
    IMPLICIT NONE
    !-------------------------------------------------------
    REAL, PARAMETER :: tol=1.E-3
    REAL            ::  rhol, rhor, ul, ur, pl, pr, al, ar,&
                        du, ducrit, p, p0, fr,             &
                        fl, frd, fld, cha, rho_star_l, rho_star_r, u, pm, um, speedl, speedr,&
                        gamma


    ! s = x/t 
    INTEGER            :: KK
    !-------------------------------------------------------
    INTENT(IN)         ::  rhol,rhor,ul,ur,pl,pr,al,ar
    INTENT(OUT)        :: rho_star_l, rho_star_r, u, p, speedl, speedr
    INTEGER, OPTIONAL:: flag
    INTEGER:: iflag
    !-------------------------------------------------------
    CALL coeff(gamma, G)
    du = ur-ul
    ducrit = G(4)*(al+ar)-du

    IF (ducrit .LE. 0.0) THEN
       PRINT *, 'Vacuum is generated by given data!!'
       PRINT *, 'rhol=',rhol 
       PRINT *, 'rhor=',rhor 
       PRINT *, 'ul=',ul 
       PRINT *, 'ur=',ur 
       PRINT *, 'pl=',pl 
       PRINT *, 'pr=',pr 
       PRINT *, 'al=',al 
       PRINT *, 'ar=',ar
       PRINT*,  'G=', G
       STOP
    END IF


    CALL STARTE(p,rhol,rhor,ul,ur,pl,pr,al,ar)




    p0  = p
    cha = 2.0*tol
    KK  = 0.0

    DO WHILE ((cha.GT.tol).AND.(KK.LT.nIter))

       KK = KK+1

       CALL PREFUN(fl,fld,p,rhol,pl,al)
       CALL PREFUN(fr,frd,p,rhor,pr,ar)

       p   = p - (fl+fr+du)/(fld+frd)
       cha = 2.0 * ABS((p-p0)/(p+p0))

       IF (p .LT. 0.0) THEN
          p = tol
       END IF

       p0=p

    END DO

    IF (KK.GE. nIter) THEN
       PRINT *, 'WARNING: Divergence in Newton-Raphson scheme'
    END IF

    u = 0.5*(ul+ur+fr-fl)

    pm = p
    um = u

    CALL SAMPLE_star(rho_star_l,rho_star_r,rhol,rhor,ul,ur,um,pl,pr,pm,al,ar,speedl,speedr,iflag)
    IF(PRESENT(flag)) flag=iflag
  END SUBROUTINE exact_riemann
  !---------------------------------------------------------
  !---------------------------------------------------------
  !---------------------------------------------------------
  SUBROUTINE STARTE(p,rhol,rhor,ul,ur,pl,pr,al,ar)
    !-------------------------------------------------------
    IMPLICIT NONE
    !-------------------------------------------------------
    REAL        ::  rhol, rhor, ul, ur, pl, pr, &
                        al, ar, p, pv, pmin,pmax,   &
                        pnu, pde, qmax,         &
                        qrat, gel, ger
    !-------------------------------------------------------
    INTENT(IN)  :: rhol,rhor,ul,ur,pl,pr,al,ar
    INTENT(OUT) :: p
    !-------------------------------------------------------

    qmax = 2.0


    pv   = 0.5*(pl+pr)-0.125*(ur-ul)*(rhol+rhor)*(al+ar)


    pmin = MIN(pl,pr)
    pmax = MAX(pl,pr)
    qrat = pmax/pmin

   
    IF ((qrat.LE.qmax).AND.((pmin.LE.pv).AND.(pv.LE.pmax))) THEN
       p = MAX(tol,pv)
    ELSE
       IF (pv.LT.pmin) THEN
          pnu = al+ar-G(7)*(ur-ul) 
          pde = al/pl**G(1) + ar/pr**G(1)
          p   = (pnu/pde)**G(3)
       ELSE
          gel = SQRT((G(5)/rhol)/(G(6)*pl+MAX(tol,pv)))
          ger = SQRT((G(5)/rhor)/(G(6)*pr+MAX(tol,pv)))
          p   = (gel*pl+ger*pr-(ur-ul))/(gel+ger)
          p   = MAX(tol,p)
       END IF
    END IF
  END SUBROUTINE STARTE
  !---------------------------------------------------------
  !---------------------------------------------------------
  !---------------------------------------------------------
  PURE ELEMENTAL SUBROUTINE PREFUN( f,fd,p,rhok,pk,ck)
    !-------------------------------------------------------
    IMPLICIT NONE
    !-------------------------------------------------------
    REAL        :: f,fd,p,rhok,pk,ck,prat,ak,qrt,bk
    !-------------------------------------------------------
    INTENT(IN)  :: p, rhok, pk, ck
    INTENT(OUT) :: f, fd
    !-------------------------------------------------------

    IF (p.LE.pk) THEN
       prat = p/pk
       f    = G(4)*ck*(prat**G(1) - 1.0)
       fd   = (1.0/(rhok*ck))*prat**(-G(2))
    ELSE
       ak  = G(5)/rhok
       bk  = G(6)*pk
       qrt = SQRT(ak/(bk+p))
       f   = (p-pk) * qrt
       fd  = (1.0-0.5*(p-pk)/(bk+p))*qrt
    END IF

  END SUBROUTINE PREFUN
  !---------------------------------------------------------
  !---------------------------------------------------------
  !---------------------------------------------------------
  PURE ELEMENTAL SUBROUTINE SAMPLE(s,p,u,rho,rhol,rhor,ul,ur,um,pl,pr,pm,al,ar)
    !-------------------------------------------------------
    IMPLICIT NONE
    !-------------------------------------------------------
    REAL       :: s,p,u,rho,rhol,rhor,ul,ur,um,pl,pr,&
                     pm,al,ar,pml,pmr,str,stl,cmr,      &
                     cml,shr,shl,sr,sl,c
    !-------------------------------------------------------
    INTENT(IN) :: s,rhol,rhor,ul,ur,um,pl,pr,pm,al,ar
    INTENT(OUT):: p,u,rho
    !-------------------------------------------------------

    IF(s.LE.um) THEN
       IF(pm.LE.pl) THEN
          shl=ul-al
          IF(s.LE.shl) THEN
             rho=rhol
             u=ul
             p=pl
          ELSE
             cml = al*(pm/pl)**G(1)
             stl = um-cml
             IF(s.GT.stl) THEN
                rho=rhol*(pm/pl)**G(8)
                u=um
                p=pm
             ELSE
                u=G(5)*(al+G(7)*ul+s)
                c=G(5)*(al+G(7)*(ul-s))
                rho=rhol*(c/al)**G(4)
                p=pl*(c/al)**G(3)
             END IF
          END IF
       ELSE
          pml = pm/pl
          sl  = ul-al*SQRT(G(2)*pml+G(1))
          IF(s.LE.sl) THEN
             rho=rhol
             u=ul
             p=pl
          ELSE
             rho=rhol*(pml+G(6))/(pml*G(6)+1.0)
             u=um
             p=pm
          END IF
       END IF
    ELSE
       IF (pm.GT.pr) THEN
          pmr=pm/pr
          sr =ur+ar*SQRT(G(2)*pmr+G(1))
          IF (s.GE.sr) THEN
             rho=rhor
             u=ur
             p=pr
          ELSE
             rho=rhor*(pmr+G(6))/(pmr*G(6)+1.0)
             u=um
             p=pm
          END IF
       ELSE
          shr=ur+ar
          IF (s.GE.SHR) THEN
             rho=rhor
             u=ur
             p=pr
          ELSE
             cmr=ar*(pm/pr)**G(1)
             str=um+cmr
             IF(s.LE.str) THEN
                rho=rhor*(pm/pr)**G(8)
                u=um
                p=pm
             ELSE
                u=G(5)*(-ar+G(7)*ur+s)
                c=G(5)*(ar-G(7)*(ur-s))
                rho=rhor*(c/ar)**G(4)
                p=pr*(c/ar)**G(3)
             END IF
          END IF
       END IF
    END IF

  END SUBROUTINE SAMPLE

  PURE ELEMENTAL SUBROUTINE SAMPLE_star(rho_star_l,rho_star_r,rhol,rhor,&
       &   ul,ur,um,pl,pr,pm,al,ar,speedl,speedr,flag)
    ! compute the star regions (i.e. the densities)
    !-------------------------------------------------------
    IMPLICIT NONE
    !-------------------------------------------------------
    REAL       :: p,u,rho_star_l,rho_star_r,rhol,rhor,ul,ur,um,pl,pr,&
               &  pm,al,ar,pml,pmr, cml, cmr, speedl, speedr
    !-------------------------------------------------------
    INTENT(IN) :: rhol,rhor,ul,ur,um,pl,pr,pm,al,ar
    INTENT(OUT):: rho_star_l, rho_star_r, speedl, speedr
    INTEGER, INTENT(out):: flag
    !-------------------------------------------------------

    flag=0  
    IF(pm.LE.pl) THEN  ! detente a gauche
       cml = al*(pm/pl)**G(1)
       speedl=um-cml
       rho_star_l=rhol*(pm/pl)**G(8)
    ELSE ! sinon choc a gauche
       pml = pm/pl
       speedl=ul-al*SQRT(G(2)*pml+G(1))
       rho_star_l=rhol*(pml+G(6))/(pml*G(6)+1.0)
       flag=-1
    END IF

    IF (pm.GT.pr) THEN ! choc a  droite
       pmr=pm/pr
       speedr=ur+ar*SQRT(G(2)*pmr+G(1))
       rho_star_r=rhor*(pmr+G(6))/(pmr*G(6)+1.0)
       flag=1
    ELSE ! detente a droite
       cmr=ar*(pm/pr)**G(1)
       speedr=um+cmr
       rho_star_r=rhor*(pm/pr)**G(8)
!!$
    END IF
  END SUBROUTINE SAMPLE_star


END MODULE exact_riemann_mod
